game.states.NonTrappedUsable = State{
    function()

        modules = {"shared.items"}

        params.CantUseAD = {
            type = EParamType.String,
            default = "GLO_AD_CannotUseNow_057cb7cf-5aa4-1ed7-9639-65530939b2f9",
            help = "PAD to play when a player uses the item while it's disabled."
        }

        params.DC = {
            type = EParamType.String,
            default="HiddenPerception_Medium_cd1800ab-1b11-4c7a-9f50-fdeb8d35481f",
            help=[[Perception check DC.]]
        }

        params.MinDistance = {
            type = EParamType.Number,
            required=false,
            default=6.0,
            help=[[Minimum distance that players are required to be in for the skill check. A distance of 0 disables the check.]]
        }

        params.OneShot = {
            type = EParamType.Bool,
            default = false,
            help = "Does the button disable itself after the first successful use?"
        }

        params.Skill = {
            type = EParamType.String,
            default="Perception",
            help=[[The skill checked for discovering the button if the 'Type' is not 'None'.]]
        }

        params.SoundOff = {
            type = EParamType.String,
            default = "PUZ_Trap_Mechanical_Off",
            help = "Sound when button is disabled"
        }

        params.SoundOn = {
            type = EParamType.String,
            default = "PUZ_Trap_Mechanical_On",
            help = "Sound when button is enabled"
        }

        params.StartEnabled = {
            type = EParamType.Bool,
            default = true,
            help = [[Does the button start enabled? (enabled = pressing it will trigger the 'Pressed' output; disabled = pressing it will the the CantUseAD, if any)]]
        }

        params.Type = {
            type = EParamType.String,
            default="Interactable",
            help=[[
            Type of invisibility. Options:
            None: No perception logic.
            Invisible: Object is invisible until discovered
            Interactable: Object is uninteractable (like scenery) until discovered. Also hides 'trapped' state, if object is trapped.
            Trapped: Hides trapped state until discovered.
            Highlight: Object is highlighted when noticed.
            ]]
        }

        params.VFXOff = {type = EParamType.String,
            required = false,
            default = "",
            help = [[VFX while button is disabled and has been spotted.]]
        }

        params.VFXOffBone = {type = EParamType.String,
            required = false,
            default = "Dummy_FX",
            help = [[Bone on which the 'VFXOff' VFX is played.]]
        }

        params.VFXOn = {type = EParamType.String,
            required = false,
            default = "",
            help = [[VFX while button is enabled and has been spotted.]]
        }

        params.VFXOnBone = {type = EParamType.String,
            required = false,
            default = "Dummy_FX",
            help = [[Bone on which the enabled-VFX is played.]]
        }

        params.Key = {
            type = EParamType.String,
            default="STORYLOCK",
            help=[[Key used when locking the item]]
        }

        inputs.Enable = {help = "Enable item use"}
        inputs.Disable = {help = "Disable item use"}

        outputs.Enable = {internal = true}
        outputs.Disable = {internal = true}

        inputs.UseBlockedFromStory = {help = [[Item use was blocked from story (because it was not enabled)]]}
        outputs.UseBlockedFromStory = {internal = true}

        outputs.ActivateAttemptFailed = {help = [[Item was used while disabled]]}
        inputs.ActivateAttemptFailed = {internal = true}

        outputs.Pressed = {help = "A player attempted to use the item (may be successful or not). Not just for pressing things, name is for backward compatibility."}
        outputs.UseFinishedSuccessfully = {help = "A character successfully finished using this item (will trigger only after closing in case of a container)"}
        outputs.UseFailed = {help = "A character failed to use this item (e.g. because it was locked, or because they're blocked from using it based on their tags)"}

        inputs.Reveal = {help = [[Reveals the item]]}
        outputs.Reveal = {internal = true}

        inputs.Lock = {help = "Lock the item using params.Key as key"}
        inputs.Unlock = {help = "Unlock the item"}

        outputs.Destroyed = {help = "Item was destroyed"}

        nodes.PerceptionDisarmOnOff = Proxy{
            game.states.PerceptionDisarmOnOff,
            params = {StartEnabled = params.StartEnabled,
                      DC = params.DC,
                      MinDistance = params.MinDistance,
                      Skill = params.Skill,
                      Type = params.Type,
                      VFXOn= params.VFXOn,
                      VFXOff = params.VFXOff,
                      VFXOnBone = params.VFXOnBone,
                      VFXOffBone = params.VFXOffBone,
                      IsTrap = false,
                      SoundOn = params.SoundOn,
                      SoundOff = params.SoundOff},
            inputs = {Enable = {outputs.Enable},
                      Disable = {outputs.Disable},
                      Reveal = {outputs.Reveal},
                      UseBlockedFromStory = {outputs.UseBlockedFromStory}},
            outputs = {ActivateAttemptFailed = {inputs.ActivateAttemptFailed}}
        }

        nodes.StoryInteractionFilter = Proxy{
            game.states.StoryInteractionFilter,
            params = {StartUseEnabled = params.StartEnabled},
            inputs = {EnableStoryItemUse = {outputs.Enable},
                      DisableStoryItemUse = {outputs.Disable},
                      UseBlockedFromStory = {outputs.UseBlockedFromStory}},
            outputs = {UseBlockedFromStory = {inputs.ActivateAttemptFailed}}
        }

        socketEvents.Enable = function(ev)
            TriggerOutput(outputs.Enable, ev.Object, ev.Param)
        end

        socketEvents.Disable = function(ev)
            TriggerOutput(outputs.Disable, ev.Object, ev.Param)
        end

        socketEvents.UseBlockedFromStory = function(ev)
            TriggerOutput(outputs.UseBlockedFromStory, ev.Object, ev.Param)
        end

        socketEvents.ActivateAttemptFailed = function(ev)
            TriggerOutput(outputs.ActivateAttemptFailed, ev.Object, ev.Param)
        end

        socketEvents.Reveal = function(ev)
            TriggerOutput(outputs.Reveal, ev.Object, ev.Param)
        end

        socketEvents.Lock = function(ev)
            if not mod.items.SafeIsDestroyed(me) then
                Lock(me, params.Key)
            end
        end

        socketEvents.Unlock = function(ev)
            if not mod.items.SafeIsDestroyed(me) then
                Unlock(me)
            end
        end

        events.UseStarted = function(ev)
            if me.Blackboard.GetFact("On") == 1 then
                StartAutomatedDialogImmediate(Dialog("GLO_AD_MechanicalClick_fc8d3dc5-b947-6354-3aa9-d1f02fd51af4"), me)
                TriggerOutput(outputs.Pressed, ev.User.EntityRef)
                if params.OneShot then
                    TriggerOutput(outputs.Disable, ev.User.EntityRef)
                end
            elseif params.CantUseAD ~= "" then
                StartAutomatedDialogImmediate(Dialog(params.CantUseAD), ev.User)
            end
        end

        events.UseFinished = function(ev)
            if me.Blackboard.GetFact("On") == 1 then
                if ev.Success then
                    TriggerOutput(outputs.UseFinishedSuccessfully, ev.User.EntityRef)
                else
                    TriggerOutput(outputs.UseFailed, ev.User.EntityRef)
                end
            end
        end

        socketEvents.UseBlockedFromStory = function(ev)
            TriggerOutput(outputs.UseBlockedFromStory, ev.Object, ev.Param)
        end

        events.Destroyed = function(ev)
            if ev.Entity == me then
                if ev.Destroyer ~= nil then
                    TriggerOutput(outputs.Destroyed, ev.Destroyer.EntityRef, ev.DestroyerOwner.EntityRef)
                else
                    TriggerOutput(outputs.Destroyed, nil, nil)
                end
            end
        end

    end

}
